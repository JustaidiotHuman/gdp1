Ausgangsversion: ~/GdPI/CodeExamples/TailCallOptimization/fac.c

Eine bekannte rekursive Version der Fakultätsfunktion.

int fac(int n){
   int res;

  if (n == 0){
    res = 1;
  } else {
    res = n * fac(n-1);
  }
  return res;
}

#------------

Variante 1: itfac1.c

Tailrekursive Variante mit Akkumulator.
Bei Übersetzung mit -O2 wird bereits Tail-Call-Optimization (TCO) durchgeführt.

int fac(int n){
  return itfac(n,1);
}

int itfac(int n, int acc){
  int res;

  if (n == 0) {
      res = acc;
    } else {
      res = itfac(n-1, n*acc); // tail-recursive call
    }

  return res;
}

#------------

Variante 2: itfac2.c

Tailrekursive Variante 2 mit Akkumulator.
Optimierung der Verzweigungsbedingung erlaubt reduktion auf einen Zweig.
Bei Übersetzung mit -O2 wird bereits Tail-Call-Optimization (TCO) durchgeführt.

int itfac(int n, int acc){
  if (n != 0) {
      acc = itfac(n-1, n*acc); // tail-recursive call
  }
  return acc;
}


#------------

Variante 3: itfac3.c

Iterativer Code

int itfac(int n, int acc){
  while (n != 0){
    acc = n*acc;
    n = n-1;
  }
  return acc;
}

Generelle Beobachtung:

gcc -O0 
* liefert für alle 3 Varianten unterschiedlichen Assemblercode:
  - bin/itfac1 und bin/itfac2 enthalten rekursive Aufrufe
  - bin/itfac3 enthält eine Schleife im Assemblercode

gcc -O2 
* liefert für alle 3 Varianten den identischen Assemblercode,
  welcher eine effiziente Schleife (tight loop) kodiert.

$ gdb -q bin/itfac1 -ex "disassemble itfac"
Reading symbols from bin/itfac1...fertig.
Dump of assembler code for function itfac:
   0x0000000000000750 <+0>:	test   %edi,%edi
   0x0000000000000752 <+2>:	mov    %esi,%eax
   0x0000000000000754 <+4>:	je     0x768 <itfac+24>
   0x0000000000000756 <+6>:	nopw   %cs:0x0(%rax,%rax,1)
   0x0000000000000760 <+16>:	imul   %edi,%eax
   0x0000000000000763 <+19>:	sub    $0x1,%edi
   0x0000000000000766 <+22>:	jne    0x760 <itfac+16>
   0x0000000000000768 <+24>:	repz retq
End of assembler dump.

# Build mit -O0

make clean; make

gcc -O0 -g -Wall itfac1.c -o bin/itfac1
gdb -q bin/itfac1 -ex "disassemble itfac"

gcc -O0 -g -Wall itfac2.c -o bin/itfac2
gdb -q bin/itfac2 -ex "disassemble itfac"

gcc -O0 -g -Wall itfac3.c -o bin/itfac3
gdb -q bin/itfac3 -ex "disassemble itfac"

# Build mit -O2

make clean; make

gcc -O2 -g -Wall itfac1.c -o bin/itfac1
gdb -q bin/itfac1 -ex "disassemble itfac"

gcc -O2 -g -Wall itfac2.c -o bin/itfac2
gdb -q bin/itfac2 -ex "disassemble itfac"

gcc -O2 -g -Wall itfac3.c -o bin/itfac3
gdb -q bin/itfac3 -ex "disassemble itfac"

===>

Es ist adäquat, tailrekursive Funktionen als iterativ zu bezeichnen.

Die Technik der Tail Call Optimization wurde bereits in den 70er Jahren
im Kontext von Funktionalen Sprachen (Lisp, Scheme) eingesetzt.
In den 80er Jahren wurden diese Technik auch für konventionelle Sprachen
wie C, C++ und Java übernommen.

Siehe https://en.wikipedia.org/wiki/Tail_call



