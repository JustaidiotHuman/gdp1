Demo: show stack frames in LLDB for example swap-V1
===================================================

Run on CISC machines x64 Intel/AMD
or  on RISC ARM platforms like raspberry Pi, Apple M1/M2).

# ----------------------------------------------------------
# Build
# ----------------------------------------------------------

cd ~/git_public_GdP1/CodeExamples/Stack
make clean; make

# ----------------------------------------------------------
# Start debugger in a terminal
# ----------------------------------------------------------
# Size 70x20

lldb bin/swap-V1 

# Notes:
#
# Note 1:
# The command script lldb_stackutils.py is imported via ~/.lldbinit
#
# Note 2:
# Due to setting 'target.skip-prologue true' we may simply set
# breakpoints at the first instruction after the function's prologue by
#    breakpoint set -n <function name>
# or even shorter
#
##   b <function name>

#----------------------------------
# Demo 1: C-Source
#----------------------------------

(lldb) list main

(lldb) b main

# Run the program

(lldb) run

# The program stops at the breakpoint

Process 3149 stopped
* thread #1, name = 'swap-V1', stop reason = breakpoint 1.1
    frame #0: 0x00005555555546b1 swap-V1` main  + 8 at swap-V1.c:21
   18  	int main() {
   19  	    int i1,i2;
   20
-> 21  	    i1=0x11223344;
   22  	    i2=0x55667788;
   23
   24  	    swap(i1,i2);

# * execute the program line by line in single steps relative to source code.
# * enter function swap
# * execute all statements of function swap
# * return from function swap
#
# Hints:
#
# next: single step one line of source code without stepping into functions
#       'next' is an abbreviation for 'thread step-over'
#
# step: single step one line of source code with stepping into functions
#       'step' is an abbreviation for 'thread step-in'
#
# finish: finish executing the current stack frame and stop after returning.
#       'finish' is an abbreviation for 'thread step-out'
#

# Hint: you may start a GUI via command gui as well.
# However, this is overkill in our case
#
# (lldb) gui

(lldb) step
(lldb) s
or simply
(lldb) <enter> will execute last command once more
...

Process 3149 stopped
* thread #1, name = 'swap-V1', stop reason = step in
    frame #0: 0x00005555555546ce swap-V1` main  + 37 at swap-V1.c:26
   23
   24  	    swap(i1,i2);
   25
-> 26  	    printf("After swap\n");
   27  	    printf("i1: %x\n",i1);
   28  	    printf("i2: %x\n",i2);
   29

# Continue until end

(lldb) cont  or simply 'c'

The programs produces output and terminates

#--------------------------------------------------------------------
# Demo 2: Display assembler code with annotated C and/or machine code
#--------------------------------------------------------------------
# Terminal 82x29

# Hints about options
# Set disassembly flavor
# -F   att: AT&T flavor  (unix, default)
# -F intel: Intel flavor (windows)
#
# Show machine code
# -b
#
# Mixed mode assembler and C code
# -m 

Show assembler code disassembled from machine of loaded target

(lldb) disassemble -n main
(lldb) dis -n main

swap-V1`main:
0x5555555546a9 <+0>:  push   rbp
0x5555555546aa <+1>:  mov    rbp, rsp
0x5555555546ad <+4>:  sub    rsp, 0x10
0x5555555546b1 <+8>:  mov    dword ptr [rbp - 0x8], 0x11223344
0x5555555546b8 <+15>: mov    dword ptr [rbp - 0x4], 0x55667788
0x5555555546bf <+22>: mov    edx, dword ptr [rbp - 0x4]
0x5555555546c2 <+25>: mov    eax, dword ptr [rbp - 0x8]
0x5555555546c5 <+28>: mov    esi, edx
0x5555555546c7 <+30>: mov    edi, eax
0x5555555546c9 <+32>: call   0x68a                     ; swap at swap-V1.c:12
0x5555555546ce <+37>: lea    rdi, [rip + 0xbf]
0x5555555546d5 <+44>: call   0x550                     ; symbol stub for: puts
0x5555555546da <+49>: mov    eax, dword ptr [rbp - 0x8]
0x5555555546dd <+52>: mov    esi, eax
0x5555555546df <+54>: lea    rdi, [rip + 0xb9]
0x5555555546e6 <+61>: mov    eax, 0x0
0x5555555546eb <+66>: call   0x560                     ; symbol stub for: printf
0x5555555546f0 <+71>: mov    eax, dword ptr [rbp - 0x4]
0x5555555546f3 <+74>: mov    esi, eax
0x5555555546f5 <+76>: lea    rdi, [rip + 0xab]
0x5555555546fc <+83>: mov    eax, 0x0
0x555555554701 <+88>: call   0x560                     ; symbol stub for: printf
0x555555554706 <+93>: mov    eax, 0x0
0x55555555470b <+98>: leave
0x55555555470c <+99>: ret

# Show mixed mode: assembler and C

(lldb) disassemble -n main -m

** 18  	int main() {

swap-V1`main:
0x5555555546a9 <+0>:  push   rbp
0x5555555546aa <+1>:  mov    rbp, rsp
0x5555555546ad <+4>:  sub    rsp, 0x10

   19  	    int i1,i2;
   20
** 21  	    i1=0x11223344;

0x5555555546b1 <+8>:  mov    dword ptr [rbp - 0x8], 0x11223344

** 22  	    i2=0x55667788;
   23

0x5555555546b8 <+15>: mov    dword ptr [rbp - 0x4], 0x55667788

** 24  	    swap(i1,i2);
   25

0x5555555546bf <+22>: mov    edx, dword ptr [rbp - 0x4]
0x5555555546c2 <+25>: mov    eax, dword ptr [rbp - 0x8]
0x5555555546c5 <+28>: mov    esi, edx
0x5555555546c7 <+30>: mov    edi, eax
0x5555555546c9 <+32>: call   0x68a                     ; swap at swap-V1.c:12

** 26  	    printf("After swap\n");

0x5555555546ce <+37>: lea    rdi, [rip + 0xbf]
0x5555555546d5 <+44>: call   0x550                     ; symbol stub for: puts

** 27  	    printf("i1: %x\n",i1);

0x5555555546da <+49>: mov    eax, dword ptr [rbp - 0x8]
0x5555555546dd <+52>: mov    esi, eax
0x5555555546df <+54>: lea    rdi, [rip + 0xb9]
0x5555555546e6 <+61>: mov    eax, 0x0
0x5555555546eb <+66>: call   0x560                     ; symbol stub for: printf

** 28  	    printf("i2: %x\n",i2);
   29

0x5555555546f0 <+71>: mov    eax, dword ptr [rbp - 0x4]
0x5555555546f3 <+74>: mov    esi, eax
0x5555555546f5 <+76>: lea    rdi, [rip + 0xab]
0x5555555546fc <+83>: mov    eax, 0x0
0x555555554701 <+88>: call   0x560                     ; symbol stub for: printf

** 30  	    return 0;

0x555555554706 <+93>: mov    eax, 0x0

** 31  	}

0x55555555470b <+98>: leave
0x55555555470c <+99>: ret

# Once more with annotated machine code (option -b)

(lldb) disassemble -n main -b

swap-V1`main:
0x5555555546a9 <+0>:  55                    push   rbp
0x5555555546aa <+1>:  48 89 e5              mov    rbp, rsp
0x5555555546ad <+4>:  48 83 ec 10           sub    rsp, 0x10
0x5555555546b1 <+8>:  c7 45 f8 44 33 22 11  mov    dword ptr [rbp - 0x8], 0x11223344
0x5555555546b8 <+15>: c7 45 fc 88 77 66 55  mov    dword ptr [rbp - 0x4], 0x55667788
0x5555555546bf <+22>: 8b 55 fc              mov    edx, dword ptr [rbp - 0x4]
0x5555555546c2 <+25>: 8b 45 f8              mov    eax, dword ptr [rbp - 0x8]
0x5555555546c5 <+28>: 89 d6                 mov    esi, edx
0x5555555546c7 <+30>: 89 c7                 mov    edi, eax
0x5555555546c9 <+32>: e8 bc ff ff ff        call   0x68a                     ; swap at swap-V1.c:12
0x5555555546ce <+37>: 48 8d 3d bf 00 00 00  lea    rdi, [rip + 0xbf]
0x5555555546d5 <+44>: e8 76 fe ff ff        call   0x550                     ; symbol stub for: puts
0x5555555546da <+49>: 8b 45 f8              mov    eax, dword ptr [rbp - 0x8]
0x5555555546dd <+52>: 89 c6                 mov    esi, eax
0x5555555546df <+54>: 48 8d 3d b9 00 00 00  lea    rdi, [rip + 0xb9]
0x5555555546e6 <+61>: b8 00 00 00 00        mov    eax, 0x0
0x5555555546eb <+66>: e8 70 fe ff ff        call   0x560                     ; symbol stub for: printf
0x5555555546f0 <+71>: 8b 45 fc              mov    eax, dword ptr [rbp - 0x4]
0x5555555546f3 <+74>: 89 c6                 mov    esi, eax
0x5555555546f5 <+76>: 48 8d 3d ab 00 00 00  lea    rdi, [rip + 0xab]
0x5555555546fc <+83>: b8 00 00 00 00        mov    eax, 0x0
0x555555554701 <+88>: e8 5a fe ff ff        call   0x560                     ; symbol stub for: printf
0x555555554706 <+93>: b8 00 00 00 00        mov    eax, 0x0
0x55555555470b <+98>: c9                    leave
0x55555555470c <+99>: c3                    ret


#----------
# Show a hex dump of the machine code of function main

x/112xb main

#>
0x5555555546a9: 0x55 0x48 0x89 0xe5 0x48 0x83 0xec 0x10
0x5555555546b1: 0xc7 0x45 0xf8 0x44 0x33 0x22 0x11 0xc7
0x5555555546b9: 0x45 0xfc 0x88 0x77 0x66 0x55 0x8b 0x55
0x5555555546c1: 0xfc 0x8b 0x45 0xf8 0x89 0xd6 0x89 0xc7
0x5555555546c9: 0xe8 0xbc 0xff 0xff 0xff 0x48 0x8d 0x3d
0x5555555546d1: 0xbf 0x00 0x00 0x00 0xe8 0x76 0xfe 0xff
0x5555555546d9: 0xff 0x8b 0x45 0xf8 0x89 0xc6 0x48 0x8d
0x5555555546e1: 0x3d 0xb9 0x00 0x00 0x00 0xb8 0x00 0x00
0x5555555546e9: 0x00 0x00 0xe8 0x70 0xfe 0xff 0xff 0x8b
0x5555555546f1: 0x45 0xfc 0x89 0xc6 0x48 0x8d 0x3d 0xab
0x5555555546f9: 0x00 0x00 0x00 0xb8 0x00 0x00 0x00 0x00
0x555555554701: 0xe8 0x5a 0xfe 0xff 0xff 0xb8 0x00 0x00
0x555555554709: 0x00 0x00 0xc9 0xc3 0x0f 0x1f 0x00 0x41
0x555555554711: 0x57 0x41 0x56 0x49 0x89 0xd7 0x41 0x55

# or use disassembler utility by Derek Selander
#
# Note: the program must be running (raw input)

(lldb) run

Process 3307 stopped
* thread #1, name = 'swap-V1', stop reason = breakpoint 1.1
    frame #0: 0x00005555555546b1 swap-V1` main  + 8 at swap-V1.c:21
   18  	int main() {
   19  	    int i1,i2;
   20
-> 21  	    i1=0x11223344;
   22  	    i2=0x55667788;
   23
   24  	    swap(i1,i2);

(lldb) dd
swap-V1, main
    0    0x5555555546a9 <+0>:    push  rbp
    1    0x5555555546aa <+1>:    mov   rbp,  rsp
    2    0x5555555546ad <+4>:    sub   rsp,  0x10
->  3    0x5555555546b1 <+8>:    mov   dword ptr [rbp - 0x8],  0x11223344
    4    0x5555555546b8 <+15>:   mov   dword ptr [rbp - 0x4],  0x55667788
    5    0x5555555546bf <+22>:   mov   edx,  dword ptr [rbp - 0x4]
    6    0x5555555546c2 <+25>:   mov   eax,  dword ptr [rbp - 0x8]
    7    0x5555555546c5 <+28>:   mov   esi,  edx
    8    0x5555555546c7 <+30>:   mov   edi,  eax
   *9    0x5555555546c9 <+32>:   call  0x55555555468a  ; swap
    10   0x5555555546ce <+37>:   lea   rdi,  [rip + 0xbf]  ; 0x555555554794 swap-V1..rodata
   *11   0x5555555546d5 <+44>:   call  0x555555554550  ; puts
    12   0x5555555546da <+49>:   mov   eax,  dword ptr [rbp - 0x8]
    13   0x5555555546dd <+52>:   mov   esi,  eax
    14   0x5555555546df <+54>:   lea   rdi,  [rip + 0xb9]  ; 0x55555555479f swap-V1..rodata
    15   0x5555555546e6 <+61>:   mov   eax,  0x0
   *16   0x5555555546eb <+66>:   call  0x555555554560  ; printf
    17   0x5555555546f0 <+71>:   mov   eax,  dword ptr [rbp - 0x4]
    18   0x5555555546f3 <+74>:   mov   esi,  eax
    19   0x5555555546f5 <+76>:   lea   rdi,  [rip + 0xab]  ; 0x5555555547a7 swap-V1..rodata
    20   0x5555555546fc <+83>:   mov   eax,  0x0
   *21   0x555555554701 <+88>:   call  0x555555554560  ; printf
    22   0x555555554706 <+93>:   mov   eax,  0x0
    23   0x55555555470b <+98>:   leave
   *24   0x55555555470c <+99>:   ret


GOHERE

#--------------------------------------------
# Demo 3: Schrittweise ausführen, stack dump
#--------------------------------------------

(lldb) list main

File: /home/regensbu/GdPI/CodeExamples/Stack/swap-V1.c
   13  	    int tmp = a;
   14  	    a = b;
   15  	    b = tmp;
   16  	}
   17
   18  	int main() {
   19  	    int i1,i2;
   20
   21  	    getchar(); // make debugger stop
   22
   23  	    i1=0x11223344;


(lldb) breakpoint set --line 23

Breakpoint 1: where = swap-V1`main + 13 at swap-V1.c:23, address = 0x000055e72b0b8706

(lldb) cont
Process 5765 resuming

Process 5765 stopped
* thread #1, name = 'swap-V1', stop reason = breakpoint 1.1
    frame #0: 0x000055e72b0b8706 swap-V1`main at swap-V1.c:23
   20
   21  	    getchar(); // make debugger stop
   22
-> 23  	    i1=0x11223344;
   24  	    i2=0x55667788;
   25
   26  	    swap(i1,i2);

# Einzelschritt: Zuweisung i1=0x11223344; ausführen

(lldb) n
Process 5765 stopped
* thread #1, name = 'swap-V1', stop reason = step over
    frame #0: 0x000055e72b0b870d swap-V1`main at swap-V1.c:24
   21  	    getchar(); // make debugger stop
   22
   23  	    i1=0x11223344;
-> 24  	    i2=0x55667788;
   25
   26  	    swap(i1,i2);
   27

# Inhalt der Variable i1 ausgeben

(lldb) fr v -f x i1

(int) i1 = 0x11223344

# Raw Dump des frames

(lldb) x/32xb $rsp
0x7fffeedecca0: 0x90 0xcd 0xde 0xee 0xff 0x7f 0x00 0x00
0x7fffeedecca8: 0x44 0x33 0x22 0x11 0x00 0x00 0x00 0x00
0x7fffeedeccb0: 0x70 0x87 0x0b 0x2b 0xe7 0x55 0x00 0x00
0x7fffeedeccb8: 0x87 0x7c 0x84 0x72 0xfb 0x7f 0x00 0x00

# Adresse von i1 ausgeben: wo liegt Variable i1 im Stack?

(lldb) p &i1
(int *) $4 = 0x00007fffeedecca8

TODO: load lldb script for dumping the stack
See lldb_stackutils.scratch

Hint:
Any time when execution in lldb stops:

- command 'f' or command 'process info' show
  the current position in the source code with some lines of context.

  (see settings


settings set stop-line-count-before 0

settings set stop-line-count-after 0


